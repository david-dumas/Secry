// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'password_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PasswordFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PasswordFailureCopyWith<$Res> {
  factory $PasswordFailureCopyWith(
          PasswordFailure value, $Res Function(PasswordFailure) then) =
      _$PasswordFailureCopyWithImpl<$Res, PasswordFailure>;
}

/// @nodoc
class _$PasswordFailureCopyWithImpl<$Res, $Val extends PasswordFailure>
    implements $PasswordFailureCopyWith<$Res> {
  _$PasswordFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TooShortCopyWith<$Res> {
  factory _$$TooShortCopyWith(
          _$TooShort value, $Res Function(_$TooShort) then) =
      __$$TooShortCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TooShortCopyWithImpl<$Res>
    extends _$PasswordFailureCopyWithImpl<$Res, _$TooShort>
    implements _$$TooShortCopyWith<$Res> {
  __$$TooShortCopyWithImpl(_$TooShort _value, $Res Function(_$TooShort) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TooShort implements TooShort {
  const _$TooShort();

  @override
  String toString() {
    return 'PasswordFailure.tooShort()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TooShort);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) {
    return tooShort();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) {
    return tooShort?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (tooShort != null) {
      return tooShort();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) {
    return tooShort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) {
    return tooShort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (tooShort != null) {
      return tooShort(this);
    }
    return orElse();
  }
}

abstract class TooShort implements PasswordFailure {
  const factory TooShort() = _$TooShort;
}

/// @nodoc
abstract class _$$NoLowercaseCharacterUsedCopyWith<$Res> {
  factory _$$NoLowercaseCharacterUsedCopyWith(_$NoLowercaseCharacterUsed value,
          $Res Function(_$NoLowercaseCharacterUsed) then) =
      __$$NoLowercaseCharacterUsedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoLowercaseCharacterUsedCopyWithImpl<$Res>
    extends _$PasswordFailureCopyWithImpl<$Res, _$NoLowercaseCharacterUsed>
    implements _$$NoLowercaseCharacterUsedCopyWith<$Res> {
  __$$NoLowercaseCharacterUsedCopyWithImpl(_$NoLowercaseCharacterUsed _value,
      $Res Function(_$NoLowercaseCharacterUsed) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoLowercaseCharacterUsed implements NoLowercaseCharacterUsed {
  const _$NoLowercaseCharacterUsed();

  @override
  String toString() {
    return 'PasswordFailure.noLowercaseCharacterUsed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NoLowercaseCharacterUsed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) {
    return noLowercaseCharacterUsed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) {
    return noLowercaseCharacterUsed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noLowercaseCharacterUsed != null) {
      return noLowercaseCharacterUsed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) {
    return noLowercaseCharacterUsed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) {
    return noLowercaseCharacterUsed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noLowercaseCharacterUsed != null) {
      return noLowercaseCharacterUsed(this);
    }
    return orElse();
  }
}

abstract class NoLowercaseCharacterUsed implements PasswordFailure {
  const factory NoLowercaseCharacterUsed() = _$NoLowercaseCharacterUsed;
}

/// @nodoc
abstract class _$$NoUppercaseCharacterUsedCopyWith<$Res> {
  factory _$$NoUppercaseCharacterUsedCopyWith(_$NoUppercaseCharacterUsed value,
          $Res Function(_$NoUppercaseCharacterUsed) then) =
      __$$NoUppercaseCharacterUsedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoUppercaseCharacterUsedCopyWithImpl<$Res>
    extends _$PasswordFailureCopyWithImpl<$Res, _$NoUppercaseCharacterUsed>
    implements _$$NoUppercaseCharacterUsedCopyWith<$Res> {
  __$$NoUppercaseCharacterUsedCopyWithImpl(_$NoUppercaseCharacterUsed _value,
      $Res Function(_$NoUppercaseCharacterUsed) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoUppercaseCharacterUsed implements NoUppercaseCharacterUsed {
  const _$NoUppercaseCharacterUsed();

  @override
  String toString() {
    return 'PasswordFailure.noUppercaseCharacterUsed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NoUppercaseCharacterUsed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) {
    return noUppercaseCharacterUsed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) {
    return noUppercaseCharacterUsed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noUppercaseCharacterUsed != null) {
      return noUppercaseCharacterUsed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) {
    return noUppercaseCharacterUsed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) {
    return noUppercaseCharacterUsed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noUppercaseCharacterUsed != null) {
      return noUppercaseCharacterUsed(this);
    }
    return orElse();
  }
}

abstract class NoUppercaseCharacterUsed implements PasswordFailure {
  const factory NoUppercaseCharacterUsed() = _$NoUppercaseCharacterUsed;
}

/// @nodoc
abstract class _$$NoSpecialCharacterUsedCopyWith<$Res> {
  factory _$$NoSpecialCharacterUsedCopyWith(_$NoSpecialCharacterUsed value,
          $Res Function(_$NoSpecialCharacterUsed) then) =
      __$$NoSpecialCharacterUsedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoSpecialCharacterUsedCopyWithImpl<$Res>
    extends _$PasswordFailureCopyWithImpl<$Res, _$NoSpecialCharacterUsed>
    implements _$$NoSpecialCharacterUsedCopyWith<$Res> {
  __$$NoSpecialCharacterUsedCopyWithImpl(_$NoSpecialCharacterUsed _value,
      $Res Function(_$NoSpecialCharacterUsed) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoSpecialCharacterUsed implements NoSpecialCharacterUsed {
  const _$NoSpecialCharacterUsed();

  @override
  String toString() {
    return 'PasswordFailure.noSpecialCharacterUsed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoSpecialCharacterUsed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) {
    return noSpecialCharacterUsed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) {
    return noSpecialCharacterUsed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noSpecialCharacterUsed != null) {
      return noSpecialCharacterUsed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) {
    return noSpecialCharacterUsed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) {
    return noSpecialCharacterUsed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noSpecialCharacterUsed != null) {
      return noSpecialCharacterUsed(this);
    }
    return orElse();
  }
}

abstract class NoSpecialCharacterUsed implements PasswordFailure {
  const factory NoSpecialCharacterUsed() = _$NoSpecialCharacterUsed;
}

/// @nodoc
abstract class _$$NoNumberUsedCopyWith<$Res> {
  factory _$$NoNumberUsedCopyWith(
          _$NoNumberUsed value, $Res Function(_$NoNumberUsed) then) =
      __$$NoNumberUsedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoNumberUsedCopyWithImpl<$Res>
    extends _$PasswordFailureCopyWithImpl<$Res, _$NoNumberUsed>
    implements _$$NoNumberUsedCopyWith<$Res> {
  __$$NoNumberUsedCopyWithImpl(
      _$NoNumberUsed _value, $Res Function(_$NoNumberUsed) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoNumberUsed implements NoNumberUsed {
  const _$NoNumberUsed();

  @override
  String toString() {
    return 'PasswordFailure.noNumberUsed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoNumberUsed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) {
    return noNumberUsed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) {
    return noNumberUsed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noNumberUsed != null) {
      return noNumberUsed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) {
    return noNumberUsed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) {
    return noNumberUsed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (noNumberUsed != null) {
      return noNumberUsed(this);
    }
    return orElse();
  }
}

abstract class NoNumberUsed implements PasswordFailure {
  const factory NoNumberUsed() = _$NoNumberUsed;
}

/// @nodoc
abstract class _$$InvalidNotComplexEnoughCopyWith<$Res> {
  factory _$$InvalidNotComplexEnoughCopyWith(_$InvalidNotComplexEnough value,
          $Res Function(_$InvalidNotComplexEnough) then) =
      __$$InvalidNotComplexEnoughCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidNotComplexEnoughCopyWithImpl<$Res>
    extends _$PasswordFailureCopyWithImpl<$Res, _$InvalidNotComplexEnough>
    implements _$$InvalidNotComplexEnoughCopyWith<$Res> {
  __$$InvalidNotComplexEnoughCopyWithImpl(_$InvalidNotComplexEnough _value,
      $Res Function(_$InvalidNotComplexEnough) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidNotComplexEnough implements InvalidNotComplexEnough {
  const _$InvalidNotComplexEnough();

  @override
  String toString() {
    return 'PasswordFailure.invalidNotComplexEnough()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidNotComplexEnough);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() tooShort,
    required TResult Function() noLowercaseCharacterUsed,
    required TResult Function() noUppercaseCharacterUsed,
    required TResult Function() noSpecialCharacterUsed,
    required TResult Function() noNumberUsed,
    required TResult Function() invalidNotComplexEnough,
  }) {
    return invalidNotComplexEnough();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? tooShort,
    TResult? Function()? noLowercaseCharacterUsed,
    TResult? Function()? noUppercaseCharacterUsed,
    TResult? Function()? noSpecialCharacterUsed,
    TResult? Function()? noNumberUsed,
    TResult? Function()? invalidNotComplexEnough,
  }) {
    return invalidNotComplexEnough?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? tooShort,
    TResult Function()? noLowercaseCharacterUsed,
    TResult Function()? noUppercaseCharacterUsed,
    TResult Function()? noSpecialCharacterUsed,
    TResult Function()? noNumberUsed,
    TResult Function()? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (invalidNotComplexEnough != null) {
      return invalidNotComplexEnough();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TooShort value) tooShort,
    required TResult Function(NoLowercaseCharacterUsed value)
        noLowercaseCharacterUsed,
    required TResult Function(NoUppercaseCharacterUsed value)
        noUppercaseCharacterUsed,
    required TResult Function(NoSpecialCharacterUsed value)
        noSpecialCharacterUsed,
    required TResult Function(NoNumberUsed value) noNumberUsed,
    required TResult Function(InvalidNotComplexEnough value)
        invalidNotComplexEnough,
  }) {
    return invalidNotComplexEnough(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TooShort value)? tooShort,
    TResult? Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult? Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult? Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult? Function(NoNumberUsed value)? noNumberUsed,
    TResult? Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
  }) {
    return invalidNotComplexEnough?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TooShort value)? tooShort,
    TResult Function(NoLowercaseCharacterUsed value)? noLowercaseCharacterUsed,
    TResult Function(NoUppercaseCharacterUsed value)? noUppercaseCharacterUsed,
    TResult Function(NoSpecialCharacterUsed value)? noSpecialCharacterUsed,
    TResult Function(NoNumberUsed value)? noNumberUsed,
    TResult Function(InvalidNotComplexEnough value)? invalidNotComplexEnough,
    required TResult orElse(),
  }) {
    if (invalidNotComplexEnough != null) {
      return invalidNotComplexEnough(this);
    }
    return orElse();
  }
}

abstract class InvalidNotComplexEnough implements PasswordFailure {
  const factory InvalidNotComplexEnough() = _$InvalidNotComplexEnough;
}
